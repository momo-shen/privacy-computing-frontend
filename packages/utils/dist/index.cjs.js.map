{"version":3,"sources":["../src/index.ts","../src/future.ts","../src/emitter.ts","../src/registry.ts"],"sourcesContent":["export * from './future';\nexport { Emitter } from './emitter';\nexport { createRegistry, Registry } from './registry';\n","type FutureStatus = PromiseSettledResult<unknown>['status'] | 'pending';\n\n/**\n * [Future](https://docs.python.org/3/library/asyncio-future.html#future-object)-like interface\n */\nexport class Future<T = void> implements Promise<T> {\n  protected readonly awaitable: Promise<T>;\n\n  protected setResult!: (result: T) => void;\n  protected setException!: (reason: unknown) => void;\n\n  protected _status: FutureStatus = 'pending';\n\n  constructor() {\n    this.awaitable = new Promise((resolve, reject) => {\n      this.setResult = resolve;\n      this.setException = reject;\n    });\n    this.then = this.awaitable.then.bind(this.awaitable);\n    this.catch = this.awaitable.catch.bind(this.awaitable);\n    this.finally = this.awaitable.finally.bind(this.awaitable);\n  }\n\n  done = () => this._status !== 'pending';\n\n  get status() {\n    return this._status;\n  }\n\n  protected set status(s: FutureStatus) {\n    if (this.done()) {\n      return;\n    }\n    this._status = s;\n  }\n\n  fulfill = (value: T) => {\n    this.setResult(value);\n    this.status = 'fulfilled';\n  };\n\n  reject = (reason?: unknown) => {\n    this.setException(reason);\n    this.status = 'rejected';\n  };\n\n  then: Promise<T>['then'];\n  catch: Promise<T>['catch'];\n  finally: Promise<T>['finally'];\n\n  get [Symbol.toStringTag]() {\n    return `[Future ${this._status}]`;\n  }\n}\n","type EventHandle<T> = (data: T) => void;\n\nexport class Emitter<T> {\n  eventHandlers: EventHandle<T>[] = [];\n\n  on = (handler: EventHandle<T>) => {\n    this.eventHandlers.push(handler);\n  };\n\n  fire = (data: T) => {\n    this.eventHandlers.forEach((evt) => {\n      evt(data);\n    });\n  };\n\n  dispose() {\n    this.eventHandlers = [];\n  }\n}\n","export class Registry<T> {\n  data: Set<T> = new Set();\n\n  register(instance: T) {\n    if (!this.data.has(instance)) {\n      this.data.add(instance);\n    }\n  }\n\n  unRegister(instance: T) {\n    if (this.data.has(instance)) {\n      this.data.delete(instance);\n    }\n  }\n\n  getData = (): T[] => {\n    return [...this.data];\n  };\n}\n\nexport function createRegistry<T>() {\n  return new Registry<T>();\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACKO,IAAM,SAAN,MAA6C;AAAA,EAC/B;AAAA,EAET;AAAA,EACA;AAAA,EAEA,UAAwB;AAAA,EAElC,cAAc;AACZ,SAAK,YAAY,IAAI,QAAQ,CAAC,SAAS,WAAW;AAChD,WAAK,YAAY;AACjB,WAAK,eAAe;AAAA,IACtB,CAAC;AACD,SAAK,OAAO,KAAK,UAAU,KAAK,KAAK,KAAK,SAAS;AACnD,SAAK,QAAQ,KAAK,UAAU,MAAM,KAAK,KAAK,SAAS;AACrD,SAAK,UAAU,KAAK,UAAU,QAAQ,KAAK,KAAK,SAAS;AAAA,EAC3D;AAAA,EAEA,OAAO,MAAM,KAAK,YAAY;AAAA,EAE9B,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAc,OAAO,GAAiB;AACpC,QAAI,KAAK,KAAK,GAAG;AACf;AAAA,IACF;AACA,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,UAAU,CAAC,UAAa;AACtB,SAAK,UAAU,KAAK;AACpB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,SAAS,CAAC,WAAqB;AAC7B,SAAK,aAAa,MAAM;AACxB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,KAAK,OAAO,WAAW,IAAI;AACzB,WAAO,WAAW,KAAK;AAAA,EACzB;AACF;;;ACnDO,IAAM,UAAN,MAAiB;AAAA,EACtB,gBAAkC,CAAC;AAAA,EAEnC,KAAK,CAAC,YAA4B;AAChC,SAAK,cAAc,KAAK,OAAO;AAAA,EACjC;AAAA,EAEA,OAAO,CAAC,SAAY;AAClB,SAAK,cAAc,QAAQ,CAAC,QAAQ;AAClC,UAAI,IAAI;AAAA,IACV,CAAC;AAAA,EACH;AAAA,EAEA,UAAU;AACR,SAAK,gBAAgB,CAAC;AAAA,EACxB;AACF;;;AClBO,IAAM,WAAN,MAAkB;AAAA,EACvB,OAAe,oBAAI,IAAI;AAAA,EAEvB,SAAS,UAAa;AACpB,QAAI,CAAC,KAAK,KAAK,IAAI,QAAQ,GAAG;AAC5B,WAAK,KAAK,IAAI,QAAQ;AAAA,IACxB;AAAA,EACF;AAAA,EAEA,WAAW,UAAa;AACtB,QAAI,KAAK,KAAK,IAAI,QAAQ,GAAG;AAC3B,WAAK,KAAK,OAAO,QAAQ;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,UAAU,MAAW;AACnB,WAAO,CAAC,GAAG,KAAK,IAAI;AAAA,EACtB;AACF;AAEO,SAAS,iBAAoB;AAClC,SAAO,IAAI,SAAY;AACzB;","names":[]}